$Id: README,v 1.7 2002-10-31 22:22:01 mike Exp $

cql-java -- a free CQL compiler for Java


This project provides a set of classes for representing a CQL parse
tree (CQLBooleanNode, CQLTermNode, etc.) and a CQLCompiler class which
builds a parse tree given a CQL query as input.  It also provides
compiler back-ends to render out the parse tree as XCQL (the XML
representation), as PQF (Yaz-style Prefix Query Format) and as CQL
(i.e. decompiling the parse-tree).  Oh, and there's a random query
generator, too.

CQL is "Common Query Language", a new query language designed under
the umbrella of the ZING initiative (Z39.59-International Next
Generation).  More information at
	http://zing.z3950.org/cql/index.html

XCQL is "XML CQL", a representation of CQL-equivalent queries in XML
which is supposed to be easier to parse.  More information at
	http://www.loc.gov/z3950/agency/zing/srwu/xcql.html
(not much more, though)

But if you didn't know that, why are you even reading this?  :-)


SYNOPSIS
--------

Test-harness:

	$ echo "foo and (bar or baz)" | java org.z3950.zing.cql.CQLParser

Library:

	import org.z3950.zing.cql.*

	// Building a parse-tree by hand
	CQLNode n1 = new CQLTermNode("dc.author", "=", "kernighan");
	CQLNode n2 = new CQLTermNode("dc.title", "all", "elements style");
	CQLNode root = new CQLAndNode(n1, n2);
	System.out.println(root.toXCQL(3));

	// Parsing a CQL query
	CQLParser parser = new CQLParser();
	CQLNode root = parser.parse("title=dinosaur");
	System.out.println(root.toXCQL(0));
	System.out.println(root.toCQL());
	System.out.println(root.toPQF(qualSet));
	// ... where `qualSet' specifies CQL-qualfier => Z-attr mapping


DESCRIPTION
-----------

See the automatically generated class documentation in the "doc"
subdirectory.  (It's not all there yet, but it's coming.)


AUTHOR
------

Mike Taylor <mike@z3950.org>
http://www.miketaylor.org.uk


LICENCE
-------

This software is open source, but I've not yet decided exactly what
licence to use.  Be good.  Assume I'm going with the GPL (most
restrictive) until I say otherwise.


SEE ALSO
--------

Adam Dickmeiss's CQL compiler, written in C.
Rob Sanderson's CQL compiler, written in Python.
All the other free CQL compilers everyone's going to write  :-)


TO DO
-----

* Add proximity support to parser -- just the back-ends left to do.

* Relation modifiers could be limited to known modifiers only.

* Fix CQLParser and CQLLexer shell-script front-ends to elegantly
  handle their classes' test harnesses' ability to read the query from
  the command-line arguments, if any, falling back to stdin if there
  are none.

* Add CQLGenerate shell-script.  Allow CQLGenerate test-harness to
  take some arguments on command-line as well as or instead of a
  file.

* Trivial CQLCanonicalise application, which renders out its source
  tree in a canonical form, enabling queries to be diffed for
  semantically significant differences only.  Tests can be run by
  generating random trees, canonicalising them, then canonicalising
  them _again_ and checking that the before-and-after results are the
  same.

* Some niceties for the cql-decompiling back-end:
	* don't emit redundant parentheses.
	* don't put spaces around relations that don't need them.

* Write pqn-generating back-end (will need to be driven from a
  configuation file specifying how to represent the qualifiers,
  relations, relation modifiers and wildcard characters as z39.50
  attributes.)

* Consider the utility of yet another back-end that translates a
  cqlnode tree into a type-1 query tree using the jzkit data
  structures.  That would be nice so that CQL could become a JZKit
  query-type, but you could achieve the same effect by generating PQN,
  and running that through JZKit's existing PQN-to-Type-1 compiler.

* Refinements to random query generator:
	* Generate relation modifiers
	* Proximity support
	* Don't always generate qualifier/relation for terms
	* Better selection of qualifier (configurable?)
	* Better selection of terms (from a dictionary file?)
	* Introduce wildcard characters into generated terms
	* Generate multi-word terms

* Write fuller "javadoc" comments.

* Write generic test suite.

